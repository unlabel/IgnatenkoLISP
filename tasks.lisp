;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;13. Определите функцию, удаляющую в исходном списке все повторные вхождения элементов.;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun list_to_set(L)
((lambda (x y)
  (cond
   ((null L) nil)
   ((member x y) (list_to_set y))
   (T (cons x (list_to_set y))))) (car L) (cdr L)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;				Тест-кейсы:					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

list_to_set '(1 1 1 2 2 3 4 1 2 3 4) ; (1 2 3 4)
list_to_set '(12 10 1 2 2 3 42 1 22 31 4 1 4 3) ; (12 10 2 42 22 31 1 4 3)




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;23. Определите функцию, которая обращает список (а b с) и разбивает его на уровни (((с) b) а).;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun REVL (L)
 (cond
  ((null L) nil)
  ((null (cdr L)) L)
  (T (list (REVL (cdr L)) (car L)))))
                  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;				Тест-кейсы:					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

 REVL '(3 2 1) ; (((1) 2) 3)    
 REVL '(1 2 3 4 2) ; (((((2) 4) 3) 2) 1)              
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;24. Определите функции,осуществляющие преобразования между видами(a b c) и (((а) b) с).;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun conv-list (lst &optional res)
  (cond ((null lst) (car res))
        (t (conv-list (cdr lst) (list (append res (list (car lst))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;				Тест-кейсы:					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

conv-list '(1 2 3) ; (((1) 2) 3)
 conv-list '(1 2 3 2 1 3) ; ((((((1) 2) 3) 2) 1) 3)
 
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;28. Определите функцию, вычисляющую, сколько всего атомов в списке (списочной структуре).;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(defun atomcount (x)
(cond ((null x) 0)
      (t  ((lambda (head tail) (cond ((atom head)  (+ 1 (atomcount tail)))
               (t (+ (atomcount head) (atomcount tail)))))
           (car x) (cdr x)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;				Тест-кейсы:					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

atomcount '(1 (2 3) 4 7) ; 5           
atomcount '(1 (2 3) 4 (7 5) (1 2 3)) ; 9





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;42. Определите функцию, находящую максимальное из значений, находящихся в вершинах дерева.;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				
(defun my-max (x y) 
( cond ((eq x nil) y) 
((eq y nil) x) 
(t (max x y)))) 

(defun max-in-tree (tree) 
(cond ((atom tree) tree) 
(t 
((lambda (root right-branch left-branch) (my-max root (my-max (max-in-tree right-branch) (max-in-tree left-branch)))) 
(car tree) (cadr tree) (cadr(cdr tree)))))) 


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;				Тест-кейсы:					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

max-in-tree `(8 ( 5 nil 6) (13 8 10)) ; 13
max-in-tree `(6 (15 (8 ( 24 13 7) 16) nil) (18 (6 nil 3) (13 2 11)))) ; 24 



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;30. Запрограммируйте интерпретатор ВЫЧИСЛИ, который преобразует инфиксную запись операций в префиксную и возвращает значение выражения. 
;;;Пример: > (ВЫЧИСЛИ ’((-2 + 4) * 3)) 6;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
Запрограммируйте интерпретатор ВЫЧИСЛИ, который преобразует инфиксную запись операций в префиксную и возвращает значение выражения. 
(defun infix-to-prefix(X)
(cond ((atom x) x) 
( t 
  ((lambda(x-head x-second x-tail)
     (cond ((atom x-head) (append (append  (list x-second)  ( list x-head) ) (list (cadr x-tail))))
      (t (append (append (list x-second) (list (infix-to-prefix x-head))) ( list (infix-to-prefix (cadr x-tail)))))))
   (car x) (cadr x) (cdr x))  )))

(defun calculate(x)
( eval ( infix-to-prefix x)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;				Тест-кейсы:					;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

calculate `((2 + 4) * 3)
18
           
           
           
           
           
           
           
           
           
           
           
           
           
           